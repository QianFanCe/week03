#coding=utf-8

import random
import matplotlib.pyplot as plt


'''
w= 0.6579382133888472 ;b= 1.6358242609408196 ;loss= 10.952019535048715
w= 1.7773838447624222 ;b= 2.7552698923143946 ;loss= 31.328963040034544
w= 3.637590602633165 ;b= 3.685373271249766 ;loss= 21.627307387674875
w= 3.0766400973274983 ;b= 3.4983897694812103 ;loss= 0.8740707483407861
w= 3.7207261968165026 ;b= 3.6594112943534616 ;loss= 0.6481982868046247
w= 0.5902723513562718 ;b= 3.0333205252614155 ;loss= 9.799741278556747

一旦遇到波动比较大的数值， 损失就很大， 产生的梯度也很大， 更新的w b也就很大
当再下次再遇到正常点时，就产生了更大的loss 导致loss越来越大
w= 19.4039574680209 ;b= 6.168934711372186 ;loss= 245.8019081034778
w= -143.26686979206394 ;b= -17.06975489721136 ;loss= 13500.917368102224
w= 1764.1480823739032 ;b= 221.35711412353453 ;loss= 1421184.2967758977

为何x减小可以收敛？

x始终小于1  w * x + b 变化较小
o = z - y loss = o ** 2
w变化不会突变 导致了梯度的稳定  核心是w的没有突变

'''
_x = [i/100 for i in range(100)]
_y = [3*e+4+random.random() for e in _x]

w = random.random()
b = random.random()

for i in range(30):
    for x, y in zip(_x, _y):
        z = w * x + b
        o = z - y
        loss = o ** 2

        dw = -2 * o * x
        db = -2 * o

        w = w + 0.1 * dw
        b = b + 0.1 * db
        print("w=", w, ";b=", b, ";loss=", loss)
plt.plot(_x,_y,".")
v = [w*e+b for e in _x]
plt.plot(_x,v)
plt.show()